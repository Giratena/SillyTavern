{
    "entries": {
        "0": {
            "uid": 0,
            "key": [],
            "keysecondary": [],
            "comment": "Expo File Manager",
            "content": "Bellow is documentation of Expo FileSystem.\n\n\nA library that provides access to the local file system on the device.\n\nexpo-file-system provides access to a file system stored locally on the device. It is also capable of uploading and downloading files from network URLs.\n\nInstallation\n\nCopy\n\nnpx expo install expo-file-system\nIf you're installing this in a bare React Native app, you should also follow these additional installation instructions.\n\nConfiguration\nUsage\nDownloading files\n\nCopy\n\n\nconst callback = downloadProgress => {\n  const progress = downloadProgress.totalBytesWritten / downloadProgress.totalBytesExpectedToWrite;\n  this.setState({\n    downloadProgress: progress,\n  });\n};\n\nconst downloadResumable = FileSystem.createDownloadResumable(\n  'http://techslides.com/demos/sample-videos/small.mp4',\n  FileSystem.documentDirectory + 'small.mp4',\n  {},\n  callback\n);\n\ntry {\n  const { uri } = await downloadResumable.downloadAsync();\n  console.log('Finished downloading to ', uri);\n} catch (e) {\n  console.error(e);\n}\n\ntry {\n  await downloadResumable.pauseAsync();\n  console.log('Paused download operation, saving for future retrieval');\n  AsyncStorage.setItem('pausedDownload', JSON.stringify(downloadResumable.savable()));\n} catch (e) {\n  console.error(e);\n}\n\ntry {\n  const { uri } = await downloadResumable.resumeAsync();\n  console.log('Finished downloading to ', uri);\n} catch (e) {\n  console.error(e);\n}\n\n//To resume a download across app restarts, assuming the DownloadResumable.savable() object was stored:\nconst downloadSnapshotJson = await AsyncStorage.getItem('pausedDownload');\nconst downloadSnapshot = JSON.parse(downloadSnapshotJson);\nconst downloadResumable = new FileSystem.DownloadResumable(\n  downloadSnapshot.url,\n  downloadSnapshot.fileUri,\n  downloadSnapshot.options,\n  callback,\n  downloadSnapshot.resumeData\n);\n\ntry {\n  const { uri } = await downloadResumable.resumeAsync();\n  console.log('Finished downloading to ', uri);\n} catch (e) {\n  console.error(e);\n}\n\nShow More\nManaging Giphy's\n\nCopy\n\n\nOpen in Snack\n\n\nimport * as FileSystem from 'expo-file-system';\n\nconst gifDir = FileSystem.cacheDirectory + 'giphy/';\nconst gifFileUri = (gifId: string) => gifDir + `gif_${gifId}_200.gif`;\nconst gifUrl = (gifId: string) => `https://media1.giphy.com/media/${gifId}/200.gif`;\n\n// Checks if gif directory exists. If not, creates it\nasync function ensureDirExists() {\n  const dirInfo = await FileSystem.getInfoAsync(gifDir);\n  if (!dirInfo.exists) {\n    console.log(\"Gif directory doesn't exist, creating…\");\n    await FileSystem.makeDirectoryAsync(gifDir, { intermediates: true });\n  }\n}\n\n// Downloads all gifs specified as array of IDs\nexport async function addMultipleGifs(gifIds: string[]) {\n  try {\n    await ensureDirExists();\n\n    console.log('Downloading', gifIds.length, 'gif files…');\n    await Promise.all(gifIds.map(id => FileSystem.downloadAsync(gifUrl(id), gifFileUri(id))));\n  } catch (e) {\n    console.error(\"Couldn't download gif files:\", e);\n  }\n}\n\n// Returns URI to our local gif file\n// If our gif doesn't exist locally, it downloads it\nexport async function getSingleGif(gifId: string) {\n  await ensureDirExists();\n\n  const fileUri = gifFileUri(gifId);\n  const fileInfo = await FileSystem.getInfoAsync(fileUri);\n\n  if (!fileInfo.exists) {\n    console.log(\"Gif isn't cached locally. Downloading…\");\n    await FileSystem.downloadAsync(gifUrl(gifId), fileUri);\n  }\n\n  return fileUri;\n}\n\n// Exports shareable URI - it can be shared outside your app\nexport async function getGifContentUri(gifId: string) {\n  return FileSystem.getContentUriAsync(await getSingleGif(gifId));\n}\n\n// Deletes whole giphy directory with all its content\nexport async function deleteAllGifs() {\n  console.log('Deleting all GIF files…');\n  await FileSystem.deleteAsync(gifDir);\n}\n\nShow More\nServer: handling multipart requests\nThe simple server in Node.js, which can save uploaded images to disk:\n\n\nCopy\n\n\nconst express = require('express');\nconst app = express();\nconst fs = require('fs');\nconst multer = require('multer');\nconst upload = multer({ dest: 'uploads/' });\n\n// This method will save the binary content of the request as a file.\napp.patch('/binary-upload', (req, res) => {\n  req.pipe(fs.createWriteStream('./uploads/image' + Date.now() + '.png'));\n  res.end('OK');\n});\n\n// This method will save a \"photo\" field from the request as a file.\napp.patch('/multipart-upload', upload.single('photo'), (req, res) => {\n  // You can access other HTTP parameters. They are located in the body object.\n  console.log(req.body);\n  res.end('OK');\n});\n\napp.listen(3000, () => {\n  console.log('Working on port 3000');\n});\n\nShow More\nAPI\nimport * as FileSystem from 'expo-file-system';\nDirectories\nThe API takes file:// URIs pointing to local files on the device to identify files. Each app only has read and write access to locations under the following directories:\n\nFileSystem.documentDirectory\nFileSystem.cacheDirectory\nSo, for example, the URI to a file named 'myFile' under 'myDirectory' in the app's user documents directory would be FileSystem.documentDirectory + 'myDirectory/myFile'.\n\nExpo APIs that create files generally operate within these directories. This includes Audio recordings, Camera photos, ImagePicker results, SQLite databases and takeSnapShotAsync() results. This allows their use with the FileSystem API.\n\nSome FileSystem functions are able to read from (but not write to) other locations.\n\nSAF URI\nA SAF URI is a URI that is compatible with the Storage Access Framework. It should look like this content://com.android.externalstorage.*. The easiest way to obtain such URI is by requestDirectoryPermissionsAsync method.\n\nConstants\nFileSystem.bundleDirectory\nType: null | string\n\n\nURI to the directory where assets bundled with the application are stored.\n\nFileSystem.cacheDirectory\nType: null | string\n\n\nfile:// URI pointing to the directory where temporary files used by this app will be stored. Files stored here may be automatically deleted by the system when low on storage. Example uses are for downloaded or generated files that the app just needs for one-time usage.\n\nFileSystem.documentDirectory\nType: null | string\n\n\nfile:// URI pointing to the directory where user documents for this app will be stored. Files stored here will remain until explicitly deleted by the app. Ends with a trailing /. Example uses are for files the user saves that they expect to see again.\n\nClasses\nDownloadResumable\nType: Class extends FileSystemCancellableNetworkTask<DownloadProgressData>\n\nDownloadResumable Methods\n\ncancelAsync()\nReturns:\nPromise<void>\n\ndownloadAsync()\nDownload the contents at a remote URI to a file in the app's file system.\n\nReturns:\nPromise<undefined | FileSystemDownloadResult>\n\nReturns a Promise that resolves to FileSystemDownloadResult object, or to undefined when task was cancelled.\n\nfileUri()\nReturns:\nstring\n\npauseAsync()\nPause the current download operation. resumeData is added to the DownloadResumable object after a successful pause operation. Returns an object that can be saved with AsyncStorage for future retrieval (the same object that is returned from calling FileSystem.DownloadResumable.savable()).\n\nReturns:\nPromise<DownloadPauseState>\n\nReturns a Promise that resolves to DownloadPauseState object.\n\nresumeAsync()\nResume a paused download operation.\n\nReturns:\nPromise<undefined | FileSystemDownloadResult>\n\nReturns a Promise that resolves to FileSystemDownloadResult object, or to undefined when task was cancelled.\n\nsavable()\nMethod to get the object which can be saved with AsyncStorage for future retrieval.\n\nReturns:\nDownloadPauseState\n\nReturns object in shape of DownloadPauseState type.\n\nFileSystemCancellableNetworkTask\nFileSystemCancellableNetworkTask Methods\n\ncancelAsync()\nReturns:\nPromise<void>\n\nUploadTask\nType: Class extends FileSystemCancellableNetworkTask<UploadProgressData>\n\nUploadTask Methods\n\ncancelAsync()\nReturns:\nPromise<void>\n\nuploadAsync()\nReturns:\nPromise<undefined | FileSystemUploadResult>\n\nMethods\nFileSystem.copyAsync(options)\nName\tType\tDescription\noptions\tRelocatingOptions\t\nA map of move options represented by RelocatingOptions type.\n\n\nCreate a copy of a file or directory. Directories are recursively copied with all of their contents. It can be also used to copy content shared by other apps to local filesystem.\n\nReturns:\nPromise<void>\n\nFileSystem.createDownloadResumable(uri, fileUri, options, callback, resumeData)\nName\tType\tDescription\nuri\tstring\t\nThe remote URI to download from.\n\nfileUri\tstring\t\nThe local URI of the file to download to. If there is no file at this URI, a new one is created. If there is a file at this URI, its contents are replaced. The directory for the file must exist.\n\noptions\n(optional)\tDownloadOptions\t\nA map of download options represented by DownloadOptions type.\n\ncallback\n(optional)\tFileSystemNetworkTaskProgressCallback<DownloadProgressData>\t\nThis function is called on each data write to update the download progress.\n\nNote: When the app has been moved to the background, this callback won't be fired until it's moved to the foreground.\n\nresumeData\n(optional)\tstring\t\nThe string which allows the api to resume a paused download. This is set on the DownloadResumable object automatically when a download is paused. When initializing a new DownloadResumable this should be null.\n\n\nCreate a DownloadResumable object which can start, pause, and resume a download of contents at a remote URI to a file in the app's file system.\n\nNote: You need to call downloadAsync(), on a DownloadResumable instance to initiate the download. The DownloadResumable object has a callback that provides download progress updates. Downloads can be resumed across app restarts by using AsyncStorage to store the DownloadResumable.savable() object for later retrieval. The savable object contains the arguments required to initialize a new DownloadResumable object to resume the download after an app restart. The directory for a local file uri must exist prior to calling this function.\n\nReturns:\nDownloadResumable\n\nFileSystem.createUploadTask(url, fileUri, options, callback)\nName\tType\nurl\tstring\nfileUri\tstring\noptions\n(optional)\tFileSystemUploadOptions\ncallback\n(optional)\tFileSystemNetworkTaskProgressCallback<UploadProgressData>\n\nReturns:\nUploadTask\n\nFileSystem.deleteAsync(fileUri, options)\nName\tType\tDescription\nfileUri\tstring\t\nfile:// or SAF URI to the file or directory.\n\noptions\n(optional)\tDeletingOptions\t\nA map of write options represented by DeletingOptions type.\n\nDefault: {}\n\nDelete a file or directory. If the URI points to a directory, the directory and all its contents are recursively deleted.\n\nReturns:\nPromise<void>\n\nFileSystem.deleteLegacyDocumentDirectoryAndroid()\nReturns:\nPromise<void>\n\nFileSystem.downloadAsync(uri, fileUri, options)\nName\tType\tDescription\nuri\tstring\t\nThe remote URI to download from.\n\nfileUri\tstring\t\nThe local URI of the file to download to. If there is no file at this URI, a new one is created. If there is a file at this URI, its contents are replaced. The directory for the file must exist.\n\noptions\n(optional)\tDownloadOptions\t\nA map of download options represented by DownloadOptions type.\n\nDefault: {}\n\nDownload the contents at a remote URI to a file in the app's file system. The directory for a local file uri must exist prior to calling this function.\n\nReturns:\nPromise<FileSystemDownloadResult>\n\nReturns a Promise that resolves to a FileSystemDownloadResult object.\n\nExample\n\nFileSystem.downloadAsync(\n  'http://techslides.com/demos/sample-videos/small.mp4',\n  FileSystem.documentDirectory + 'small.mp4'\n)\n  .then(({ uri }) => {\n    console.log('Finished downloading to ', uri);\n  })\n  .catch(error => {\n    console.error(error);\n  });\nOnly for: \n\nFileSystem.getContentUriAsync(fileUri)\nName\tType\tDescription\nfileUri\tstring\t\nThe local URI of the file. If there is no file at this URI, an exception will be thrown.\n\n\nTakes a file:// URI and converts it into content URI (content://) so that it can be accessed by other applications outside of Expo.\n\nReturns:\nPromise<string>\n\nReturns a Promise that resolves to a string containing a content:// URI pointing to the file. The URI is the same as the fileUri input parameter but in a different format.\n\nExample\n\nFileSystem.getContentUriAsync(uri).then(cUri => {\n  console.log(cUri);\n  IntentLauncher.startActivityAsync('android.intent.action.VIEW', {\n    data: cUri,\n    flags: 1,\n  });\n});\nFileSystem.getFreeDiskStorageAsync()\nGets the available internal disk storage size, in bytes. This returns the free space on the data partition that hosts all of the internal storage for all apps on the device.\n\nReturns:\nPromise<number>\n\nReturns a Promise that resolves to the number of bytes available on the internal disk, or JavaScript's MAX_SAFE_INTEGER if the capacity is greater than 253 - 1 bytes.\n\nFileSystem.getInfoAsync(fileUri, options)\nName\tType\tDescription\nfileUri\tstring\t\nURI to the file or directory. See supported URI schemes.\n\noptions\n(optional)\tInfoOptions\t\nA map of options represented by InfoOptions type.\n\nDefault: {}\n\nGet metadata information about a file, directory or external content/asset.\n\nReturns:\nPromise<FileInfo>\n\nA Promise that resolves to a FileInfo object. If no item exists at this URI, the returned Promise resolves to FileInfo object in form of { exists: false, isDirectory: false }.\n\nFileSystem.getTotalDiskCapacityAsync()\nGets total internal disk storage size, in bytes. This is the total capacity of the data partition that hosts all the internal storage for all apps on the device.\n\nReturns:\nPromise<number>\n\nReturns a Promise that resolves to a number that specifies the total internal disk storage capacity in bytes, or JavaScript's MAX_SAFE_INTEGER if the capacity is greater than 253 - 1 bytes.\n\nFileSystem.makeDirectoryAsync(fileUri, options)\nName\tType\tDescription\nfileUri\tstring\t\nfile:// URI to the new directory to create.\n\noptions\n(optional)\tMakeDirectoryOptions\t\nA map of create directory options represented by MakeDirectoryOptions type.\n\nDefault: {}\n\nCreate a new empty directory.\n\nReturns:\nPromise<void>\n\nFileSystem.moveAsync(options)\nName\tType\tDescription\noptions\tRelocatingOptions\t\nA map of move options represented by RelocatingOptions type.\n\n\nMove a file or directory to a new location.\n\nReturns:\nPromise<void>\n\nFileSystem.readAsStringAsync(fileUri, options)\nName\tType\tDescription\nfileUri\tstring\t\nfile:// or SAF URI to the file or directory.\n\noptions\n(optional)\tReadingOptions\t\nA map of read options represented by ReadingOptions type.\n\nDefault: {}\n\nRead the entire contents of a file as a string. Binary will be returned in raw format, you will need to append data:image/png;base64, to use it as Base64.\n\nReturns:\nPromise<string>\n\nA Promise that resolves to a string containing the entire contents of the file.\n\nFileSystem.readDirectoryAsync(fileUri)\nName\tType\tDescription\nfileUri\tstring\t\nfile:// URI to the directory.\n\n\nEnumerate the contents of a directory.\n\nReturns:\nPromise<string[]>\n\nA Promise that resolves to an array of strings, each containing the name of a file or directory contained in the directory at fileUri.\n\nFileSystem.uploadAsync(url, fileUri, options)\nName\tType\tDescription\nurl\tstring\t\nThe remote URL, where the file will be sent.\n\nfileUri\tstring\t\nThe local URI of the file to send. The file must exist.\n\noptions\n(optional)\tFileSystemUploadOptions\t\nA map of download options represented by FileSystemUploadOptions type.\n\nDefault: {}\n\nUpload the contents of the file pointed by fileUri to the remote url.\n\nReturns:\nPromise<FileSystemUploadResult>\n\nReturns a Promise that resolves to FileSystemUploadResult object.\n\nExample\n\nClient\n\nimport * as FileSystem from 'expo-file-system';\n\ntry {\n  const response = await FileSystem.uploadAsync(`http://192.168.0.1:1234/binary-upload`, fileUri, {\n    fieldName: 'file',\n    httpMethod: 'PATCH',\n    uploadType: FileSystem.FileSystemUploadType.BINARY_CONTENT,\n  });\n  console.log(JSON.stringify(response, null, 4));\n} catch (error) {\n  console.log(error);\n}\nServer\n\nPlease refer to the \"Server: Handling multipart requests\" example - there is code for a simple Node.js server.\n\nFileSystem.writeAsStringAsync(fileUri, contents, options)\nName\tType\tDescription\nfileUri\tstring\t\nfile:// or SAF URI to the file or directory.\n\nNote: when you're using SAF URI the file needs to exist. You can't create a new file.\n\ncontents\tstring\t\nThe string to replace the contents of the file with.\n\noptions\n(optional)\tWritingOptions\t\nA map of write options represented by WritingOptions type.\n\nDefault: {}\n\nWrite the entire contents of a file as a string.\n\nReturns:\nPromise<void>\n\nNamespaces\nStorageAccessFramework\nOnly for: \n\nThe StorageAccessFramework is a namespace inside of the expo-file-system module, which encapsulates all functions which can be used with SAF URIs. You can read more about SAF in the Android documentation.\n\nExample\n\nBasic Usage\nimport { StorageAccessFramework } from 'expo-file-system';\n\n// Requests permissions for external directory\nconst permissions = await StorageAccessFramework.requestDirectoryPermissionsAsync();\n\nif (permissions.granted) {\n  // Gets SAF URI from response\n  const uri = permissions.directoryUri;\n\n  // Gets all files inside of selected directory\n  const files = await StorageAccessFramework.readDirectoryAsync(uri);\n  alert(`Files inside ${uri}:\\n\\n${JSON.stringify(files)}`);\n}\nMigrating an album\nimport * as MediaLibrary from 'expo-media-library';\nimport * as FileSystem from 'expo-file-system';\nconst { StorageAccessFramework } = FileSystem;\n\nasync function migrateAlbum(albumName: string) {\n  // Gets SAF URI to the album\n  const albumUri = StorageAccessFramework.getUriForDirectoryInRoot(albumName);\n\n  // Requests permissions\n  const permissions = await StorageAccessFramework.requestDirectoryPermissionsAsync(albumUri);\n  if (!permissions.granted) {\n    return;\n  }\n\n  const permittedUri = permissions.directoryUri;\n  // Checks if users selected the correct folder\n  if (!permittedUri.includes(albumName)) {\n    return;\n  }\n\n  const mediaLibraryPermissions = await MediaLibrary.requestPermissionsAsync();\n  if (!mediaLibraryPermissions.granted) {\n    return;\n  }\n\n  // Moves files from external storage to internal storage\n  await StorageAccessFramework.moveAsync({\n    from: permittedUri,\n    to: FileSystem.documentDirectory!,\n  });\n\n  const outputDir = FileSystem.documentDirectory! + albumName;\n  const migratedFiles = await FileSystem.readDirectoryAsync(outputDir);\n\n  // Creates assets from local files\n  const [newAlbumCreator, ...assets] = await Promise.all(\n    migratedFiles.map<Promise<MediaLibrary.Asset>>(\n      async fileName => await MediaLibrary.createAssetAsync(outputDir + '/' + fileName)\n    )\n  );\n\n  // Album was empty\n  if (!newAlbumCreator) {\n    return;\n  }\n\n  // Creates a new album in the scoped directory\n  const newAlbum = await MediaLibrary.createAlbumAsync(albumName, newAlbumCreator, false);\n  if (assets.length) {\n    await MediaLibrary.addAssetsToAlbumAsync(assets, newAlbum, false);\n  }\n}\nStorageAccessFramework Methods\n\ncopyAsync(options)\nName\tType\noptions\tRelocatingOptions\n\nAlias for copyAsync method.\n\nReturns:\nPromise<void>\n\ncreateFileAsync(parentUri, fileName, mimeType)\nName\tType\tDescription\nparentUri\tstring\t\nThe SAF URI to the parent directory.\n\nfileName\tstring\t\nThe name of new file without the extension.\n\nmimeType\tstring\t\nThe MIME type of new file.\n\n\nCreates a new empty file.\n\nReturns:\nPromise<string>\n\nA Promise that resolves to a SAF URI to the created file.\n\ndeleteAsync(fileUri, options)\nName\tType\nfileUri\tstring\noptions\n(optional)\tDeletingOptions\n\nAlias for deleteAsync method.\n\nReturns:\nPromise<void>\n\ngetUriForDirectoryInRoot(folderName)\nName\tType\tDescription\nfolderName\tstring\t\nThe name of the folder which is located in the Android root directory.\n\n\nGets a SAF URI pointing to a folder in the Android root directory. You can use this function to get URI for StorageAccessFramework.requestDirectoryPermissionsAsync() when you trying to migrate an album. In that case, the name of the album is the folder name.\n\nReturns:\nstring\n\nReturns a SAF URI to a folder.\n\nmakeDirectoryAsync(parentUri, dirName)\nName\tType\tDescription\nparentUri\tstring\t\nThe SAF URI to the parent directory.\n\ndirName\tstring\t\nThe name of new directory.\n\n\nCreates a new empty directory.\n\nReturns:\nPromise<string>\n\nA Promise that resolves to a SAF URI to the created directory.\n\nmoveAsync(options)\nName\tType\noptions\tRelocatingOptions\n\nAlias for moveAsync method.\n\nReturns:\nPromise<void>\n\nreadAsStringAsync(fileUri, options)\nName\tType\nfileUri\tstring\noptions\n(optional)\tReadingOptions\n\nAlias for readAsStringAsync method.\n\nReturns:\nPromise<string>\n\nreadDirectoryAsync(dirUri)\nName\tType\tDescription\ndirUri\tstring\t\nSAF URI to the directory.\n\n\nEnumerate the contents of a directory.\n\nReturns:\nPromise<string[]>\n\nA Promise that resolves to an array of strings, each containing the full SAF URI of a file or directory contained in the directory at fileUri.\n\nOnly for: \n\nrequestDirectoryPermissionsAsync(initialFileUrl)\nName\tType\tDescription\ninitialFileUrl\n(optional)\tnull | string\t\nThe SAF URI of the directory that the file picker should display when it first loads. If URI is incorrect or points to a non-existing folder, it's ignored.\n\nDefault: null\n\nAllows users to select a specific directory, granting your app access to all of the files and sub-directories within that directory.\n\nReturns:\nPromise<FileSystemRequestDirectoryPermissionsResult>\n\nReturns a Promise that resolves to FileSystemRequestDirectoryPermissionsResult object.\n\nwriteAsStringAsync(fileUri, contents, options)\nName\tType\nfileUri\tstring\ncontents\tstring\noptions\n(optional)\tWritingOptions\n\nAlias for writeAsStringAsync method.\n\nReturns:\nPromise<void>\n\nTypes\nDeletingOptions\nName\tType\tDescription\nidempotent\n(optional)\tboolean\t\nIf true, don't throw an error if there is no file or directory at this URI.\n\nDefault: false\nDownloadOptions\nName\tType\tDescription\ncache\n(optional)\tboolean\t-\nheaders\n(optional)\tRecord<string, string>\t\nAn object containing all the HTTP header fields and their values for the download network request. The keys and values of the object are the header names and values respectively.\n\nmd5\n(optional)\tboolean\t\nIf true, include the MD5 hash of the file in the returned object. Provided for convenience since it is common to check the integrity of a file immediately after downloading.\n\nDefault: false\nsessionType\n(optional)\tFileSystemSessionType\t\nOnly for: \n\nA session type. Determines if tasks can be handled in the background. On Android, sessions always work in the background and you can't change it.\n\nDefault: FileSystemSessionType.BACKGROUND\nDownloadPauseState\nName\tType\tDescription\nfileUri\tstring\t\nThe local URI of the file to download to. If there is no file at this URI, a new one is created. If there is a file at this URI, its contents are replaced.\n\noptions\tDownloadOptions\t\nObject representing the file download options.\n\nresumeData\n(optional)\tstring\t\nThe string which allows the API to resume a paused download.\n\nurl\tstring\t\nThe remote URI to download from.\n\nDeprecated. use FileSystemNetworkTaskProgressCallback<DownloadProgressData> instead.\n\nDownloadProgressCallback\nType: FileSystemNetworkTaskProgressCallback<DownloadProgressData>\n\nDownloadProgressData\nName\tType\tDescription\ntotalBytesExpectedToWrite\tnumber\t\nThe total bytes expected to be written by the download operation. A value of -1 means that the server did not return the Content-Length header and the total size is unknown. Without this header, you won't be able to track the download progress.\n\ntotalBytesWritten\tnumber\t\nThe total bytes written by the download operation.\n\nDeprecated. Use FileSystemDownloadResult instead.\n\nDownloadResult\nType: FileSystemDownloadResult\n\nFileInfo\nType: object shaped as below:\n\n\nName\tType\tDescription\nexists\ttrue\t\nSignifies that the requested file exist.\n\nisDirectory\tboolean\t\nBoolean set to true if this is a directory and false if it is a file.\n\nmd5\n(optional)\tstring\t\nPresent if the md5 option was truthy. Contains the MD5 hash of the file.\n\nmodificationTime\tnumber\t\nThe last modification time of the file expressed in seconds since epoch.\n\nsize\tnumber\t\nThe size of the file in bytes. If operating on a source such as an iCloud file, only present if the size option was truthy.\n\nuri\tstring\t\nA file:// URI pointing to the file. This is the same as the fileUri input parameter.\n\n\nName\tType\tDescription\nexists\tfalse\t-\nisDirectory\tfalse\t-\nuri\tstring\t-\nFileSystemAcceptedUploadHttpMethod\nLiteral Type: string\n\nAcceptable values are: 'POST' | 'PUT' | 'PATCH'\n\nFileSystemDownloadResult\nType: FileSystemHttpResult extended by:\n\n\nName\tType\tDescription\nmd5\n(optional)\tstring\t\nPresent if the md5 option was truthy. Contains the MD5 hash of the file.\n\nuri\tstring\t\nA file:// URI pointing to the file. This is the same as the fileUri input parameter.\n\nFileSystemHttpResult\nName\tType\tDescription\nheaders\tRecord<string, string>\t\nAn object containing all the HTTP response header fields and their values for the download network request. The keys and values of the object are the header names and values respectively.\n\nmimeType\tstring | null\t-\nstatus\tnumber\t\nThe HTTP response status code for the download network request.\n\nFileSystemNetworkTaskProgressCallback()\nName\tType\ndata\tT\nFileSystemRequestDirectoryPermissionsResult\nType: object shaped as below:\n\n\nName\tType\tDescription\ngranted\tfalse\t-\n\nName\tType\tDescription\ndirectoryUri\tstring\t\nThe SAF URI to the user's selected directory. Available only if permissions were granted.\n\ngranted\ttrue\t-\nFileSystemUploadOptions\nType: UploadOptionsBinary | UploadOptionsMultipart extended by:\n\n\nName\tType\tDescription\nheaders\n(optional)\tRecord<string, string>\t\nAn object containing all the HTTP header fields and their values for the upload network request. The keys and values of the object are the header names and values respectively.\n\nhttpMethod\n(optional)\tFileSystemAcceptedUploadHttpMethod\t\nThe request method.\n\nDefault: FileSystemAcceptedUploadHttpMethod.POST\nsessionType\n(optional)\tFileSystemSessionType\t\nOnly for: \n\nA session type. Determines if tasks can be handled in the background. On Android, sessions always work in the background and you can't change it.\n\nDefault: FileSystemSessionType.BACKGROUND\nFileSystemUploadResult\nType: FileSystemHttpResult extended by:\n\n\nName\tType\tDescription\nbody\tstring\t\nThe body of the server response.\n\nInfoOptions\nName\tType\tDescription\nmd5\n(optional)\tboolean\t\nWhether to return the MD5 hash of the file.\n\nDefault: false\nsize\n(optional)\tboolean\t\nExplicitly specify that the file size should be included. For example, skipping this can prevent downloading the file if it's stored in iCloud. The size is always returned for file:// locations.\n\nMakeDirectoryOptions\nName\tType\tDescription\nintermediates\n(optional)\tboolean\t\nIf true, don't throw an error if there is no file or directory at this URI.\n\nDefault: false\nProgressEvent\nName\tType\tDescription\ndata\tT\t-\nuuid\tstring\t-\nReadingOptions\nName\tType\tDescription\nencoding\n(optional)\tEncodingType | 'utf8' | 'base64'\t\nThe encoding format to use when reading the file.\n\nDefault: EncodingType.UTF8\nlength\n(optional)\tnumber\t\nOptional number of bytes to read. This option is only used when encoding: FileSystem.EncodingType.Base64 and position is defined.\n\nposition\n(optional)\tnumber\t\nOptional number of bytes to skip. This option is only used when encoding: FileSystem.EncodingType.Base64 and length is defined.\n\nRelocatingOptions\nName\tType\tDescription\nfrom\tstring\t\nURI or SAF URI to the asset, file, or directory. See supported URI schemes.\n\nto\tstring\t\nfile:// URI to the file or directory which should be its new location.\n\nUploadOptionsBinary\nUpload options when upload type is set to binary.\n\nName\tType\tDescription\nuploadType\n(optional)\tFileSystemUploadType\t\nUpload type determines how the file will be sent to the server. Value will be FileSystemUploadType.BINARY_CONTENT.\n\nUploadOptionsMultipart\nUpload options when upload type is set to multipart.\n\nName\tType\tDescription\nfieldName\n(optional)\tstring\t\nThe name of the field which will hold uploaded file. Defaults to the file name without an extension.\n\nmimeType\n(optional)\tstring\t\nThe MIME type of the provided file. If not provided, the module will try to guess it based on the extension.\n\nparameters\n(optional)\tRecord<string, string>\t\nAdditional form properties. They will be located in the request body.\n\nuploadType\tFileSystemUploadType\t\nUpload type determines how the file will be sent to the server. Value will be FileSystemUploadType.MULTIPART.\n\nUploadProgressData\nName\tType\tDescription\ntotalBytesExpectedToSend\tnumber\t\nThe total bytes expected to be sent by the upload operation.\n\ntotalBytesSent\tnumber\t\nThe total bytes sent by the upload operation.\n\nWritingOptions\nName\tType\tDescription\nencoding\n(optional)\tEncodingType | 'utf8' | 'base64'\t\nThe encoding format to use when writing the file.\n\nDefault: FileSystem.EncodingType.UTF8\nEnums\nEncodingType\nThese values can be used to define how file system data is read / written.\n\nEncodingType Values\n\nBase64\nEncodingType.Base64 ＝ \"base64\"\nBinary, radix-64 representation.\n\nUTF8\nEncodingType.UTF8 ＝ \"utf8\"\nStandard encoding format.\n\nOnly for: \n\nFileSystemSessionType\nThese values can be used to define how sessions work on iOS.\n\nFileSystemSessionType Values\n\nBACKGROUND\nFileSystemSessionType.BACKGROUND ＝ 0\nUsing this mode means that the downloading/uploading session on the native side will work even if the application is moved to background. If the task completes while the application is in background, the Promise will be either resolved immediately or (if the application execution has already been stopped) once the app is moved to foreground again.\n\nNote: The background session doesn't fail if the server or your connection is down. Rather, it continues retrying until the task succeeds or is canceled manually.\n\nFOREGROUND\nFileSystemSessionType.FOREGROUND ＝ 1\nUsing this mode means that downloading/uploading session on the native side will be terminated once the application becomes inactive (e.g. when it goes to background). Bringing the application to foreground again would trigger Promise rejection.\n\nFileSystemUploadType\nFileSystemUploadType Values\n\nBINARY_CONTENT\nFileSystemUploadType.BINARY_CONTENT ＝ 0\nThe file will be sent as a request's body. The request can't contain additional data.\n\nMULTIPART\nFileSystemUploadType.MULTIPART ＝ 1\nAn RFC 2387-compliant request body. The provided file will be encoded into HTTP request. This request can contain additional data represented by UploadOptionsMultipart type.\n\nSupported URI schemes\nIn this table, you can see what type of URI can be handled by each method. For example, if you have an URI, which begins with content://, you cannot use FileSystem.readAsStringAsync(), but you can use FileSystem.copyAsync() which supports this scheme.\n\nMethod name\tAndroid\tiOS\ngetInfoAsync\tfile:///,\ncontent://,\nasset://,\nno scheme\tfile://,\nph://,\nassets-library://\nreadAsStringAsync\tfile:///,\nasset://,\nSAF URI\tfile://\nwriteAsStringAsync\tfile:///,\nSAF URI\tfile://\ndeleteAsync\tfile:///,\nSAF URI\tfile://\nmoveAsync\tSource:\nfile:///,\nSAF URI\n\nDestination:\nfile://\tSource:\nfile://\n\nDestination:\nfile://\ncopyAsync\tSource:\nfile:///,\ncontent://,\nasset://,\nSAF URI,\nno scheme\n\nDestination:\nfile://\tSource:\nfile://,\nph://,\nassets-library://\n\nDestination:\nfile://\nmakeDirectoryAsync\tfile:///\tfile://\nreadDirectoryAsync\tfile:///\tfile://\ndownloadAsync\tSource:\nhttp://,\nhttps://\n\nDestination:\nfile:///\tSource:\nhttp://,\nhttps://\n\nDestination:\nfile://\nuploadAsync\tSource:\nfile:///\n\nDestination:\nhttp://\nhttps://\tSource:\nfile://\n\nDestination:\nhttp://\nhttps://\ncreateDownloadResumable\tSource:\nhttp://,\nhttps://\n\nDestination:\nfile:///\tSource:\nhttp://,\nhttps://\n\nDestination:\nfile://\nOn Android no scheme defaults to a bundled resource.\n\nPermissions\nAndroid\nThe following permissions are added automatically through this library's AndroidManifest.xml.\n\nAndroid Permission\tDescription\nREAD_EXTERNAL_STORAGE\n\nAllows an application to read from external storage.\n\nWRITE_EXTERNAL_STORAGE\n\nAllows an application to write to external storage.\n\nINTERNET\n\nAllows applications to open network sockets.\n\niOS\nNo permissions required.",
            "constant": false,
            "vectorized": false,
            "selective": true,
            "selectiveLogic": 0,
            "addMemo": true,
            "order": 100,
            "position": 1,
            "disable": true,
            "excludeRecursion": false,
            "preventRecursion": false,
            "delayUntilRecursion": false,
            "probability": 100,
            "useProbability": true,
            "depth": 4,
            "group": "",
            "groupOverride": false,
            "groupWeight": 100,
            "scanDepth": null,
            "caseSensitive": null,
            "matchWholeWords": null,
            "useGroupScoring": null,
            "automationId": "",
            "role": null,
            "displayIndex": 0
        }
    }
}